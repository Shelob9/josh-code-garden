{"pageProps":{"note":{"title":"Laravel Queues","content":"- [Learn Laravel Queues](https://learn-laravel-queues.com) - 5 stars! Buy This.\r\n- [Serverless Laravel](https://serverlesslaravelcourse.com/) - 5 stars! Buy this if using Vapor.\r\n- [Documentation](https://laravel.com/docs/8.x/queues)\r\n- [[laravel]]\r\n\r\n## Serial Vs Parallel Requests With Laravel Queues\r\n\r\nA chain of jobs is executed in series, one after another. Batching can be used to run jobs in paralled. In both cases, you can call a function when the chain or bacth is done or when an error is caught.\r\n\r\nOn Vapor, queues are not first in first out -- FIDO -- and jobs can run more then once. So whether jobs are in chain or dispatched in a loop, they will run out of order.\r\n\r\n### Science\r\n\r\nI wrote two commands, that dispatch this job a hundred times:\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Jobs;\r\n\r\nuse Illuminate\\Bus\\Queueable;\r\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\r\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\r\nuse Illuminate\\Queue\\InteractsWithQueue;\r\nuse Illuminate\\Queue\\SerializesModels;\r\n\r\nclass LogTimeAndArgsJob implements ShouldQueue\r\n{\r\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\r\n\r\n    /* @var int */\r\n    protected $itteration;\r\n\r\n    /* @var string */\r\n    protected $command;\r\n\r\n    /**\r\n     * @param int $itteration\r\n     * @param string $command\r\n     */\r\n    public function __construct(int $itteration, string $command)\r\n    {\r\n        $this->itteration = $itteration;\r\n        $this->command = $command;\r\n    }\r\n\r\n    public function handle()\r\n    {\r\n        logger(sprintf('Itteration: %s Command: %s', $this->itteration,$this->command) );\r\n    }\r\n}\r\n```\r\n\r\nUsing a loop to dipsatch jobs in order:\r\n\r\n```php\r\nArtisan::command('test:loop', function (){\r\n    for( $i = 0;$i <=100;$i++){\r\n      dispatch( new \\App\\Jobs\\LogTimeAndArgsJob($i,'test:loop'));\r\n    }\r\n\r\n});\r\n```\r\n\r\nAnd using a chain:\r\n\r\n```php\r\nArtisan::command('test:chain', function (){\r\n    $jobs = [];\r\n    for( $i = 0;$i <=100;$i++){\r\n        $jobs[] = new \\App\\Jobs\\LogTimeAndArgsJob($i,'test:chain');\r\n    }\r\n\r\n    \\Illuminate\\Support\\Facades\\Bus::chain(\r\n       $jobs\r\n    )->catch(function() {\r\n        logger('test:chain failed' );\r\n    })->dispatch();\r\n});\r\n```\r\n\r\nI deployed this to Vapor, and used Vapor UI to trigger both commands. As I expected, the jobs dispatched with a loop ran in mildly random order. The chain executed in order of itterations.\r\n\r\nDispatching a chain from a command did cause my comamnd to take longer.\r\n\r\n```yaml\r\nenvironments:\r\n  production:\r\n    cli-timeout: 600\r\n    queue-timeout: 600\r\n```\r\n\r\n## Laravel Vapor Queue 413 Errors\r\n\r\nI noticed, in my logs, some 413 entity too large errors that mentioned SQS. Laravel serializes models of job classes. Laravel Vapor uses HTTP POST request to send the serialized model to the queue. If the model has an attribute that is an array and that array is bigger then whatever is the limit for a payload sent to the SQS, then well, I had an error.\r\n\r\nI avoided this by passing the id of the model, not the model. This adds some database queries, but also avoids sending huge payloads to SQS and getting errors. Also, I don't know this to be true, but I assume we're getting billed for SQS payload size. But I didn't look it up, beacuse AWS.\r\n\r\nI'm trying to use jobs to clean up and count data, 500 or so rows at a time. The model I was serializing was the \"Summary\" model, which stores the counts. I want the UI to query for one or a few summaries, not all of the data that the summary is based on. Time is litteraly money.\r\n\r\nSo this was actually a good refactor. In my original plan, the summary model was insantiated once and then passed to each job before they were dispatched. This sort of worked when I was dealing with less then 10,000 records that needed cleaned up. Now that I think about it, I am really unclear why.\r\n\r\nUsing the chain, I knew jobs would run page 1, page 2, etc. Having to query for the model in between jobs prevented having to worry about deserializing a model that was serialized at the \"wrong\" state. Whatever that actually means.\r\n\r\n## Ensuring A Job Only (Effectively) Runs Once In Laravel Vapor\r\n\r\nIn Laravel Vapor a job may run more than once. Can't stop it. Can't Stop The Signal Mal.\r\n\r\nThis was an issue for me, when I'm trying to use jobs to clean up and count data, 500 or so rows at a time. Counting a page twice makes the math incorrect.\r\n\r\nMy solution was to save an array of page numbers that had been processed. If a job is processed for page 5, but page 5 is already processed, I just don't don't process that page again.\r\n\r\n## Testing Laravel Queues\r\n\r\n### Testing A Laravel Command That Dispatches A job\r\n\r\nBe careful of `Error: Call to undefined method Illuminate\\Support\\Testing\\Fakes\\BusFake::chain()` happens if faking bus in a test that uses a chain.\r\n\r\n```php\r\n//Mock Bus to test jobs dispatched\r\nuse Illuminate\\Support\\Facades\\Bus;\r\n//Mock queue to test jobs pushed into queue using a chain.\r\nuse Illuminate\\Support\\Facades\\Queue;\r\n\r\nclass SomeTests exteds TestCase {\r\n    public function testDispatches()\r\n    {\r\n        //Mock queue bus\r\n        Bus::fake();\r\n        $this->artisan('command that calls a job');\r\n        //Assert command dispatched a job 2 times\r\n        Bus::assertDispatched(WhateverJob::class,2);\r\n\r\n    }\r\n\r\n    public function testChained()\r\n    {\r\n        //Mock queue\r\n        Queue::fake();\r\n        $this->artisan('command that chaines');\r\n        //Assert job was pushed one times\r\n            (WhateverJob::class,1);\r\n    }\r\n}\r\n```\r\n","slug":"laravel-queue","references":[{"slug":"laravel","url":"/notes/laravel"}]},"slug":"laravel-queue"},"__N_SSG":true}