{"pageProps":{"note":{"content":"--- \r\ntitle: Basics of Typesscript\r\nslug: typescript-basics\r\n---\r\n\r\n## Introduction\r\n\r\n### Why\r\n\r\nTypescript makes it harder to write JavaScript incorrectly.\r\n\r\n### What\r\n\r\nTypescript is a dailect of JavaScript that adds new syntax to define types and interfaces for variables, function arguments, function return types and objects. The typescript compiler to\r\n\r\n### Quick Start\r\n\r\nTo get started with Typescript without worrying about setup, you can create a new project using [tsdx](https://github.com/jaredpalmer/tsdx):\r\n\r\n```bash\r\nnpx tsdx create learn-typescript\r\n```\r\n\r\nAlso, [adding typescript to create-react-app](https://create-react-app.dev/docs/adding-typescript/) is documented and straight-forward.\r\n\r\nI wrote [a longer introduction for Pantheon](https://pantheon.io/blog/typescript-wordpress-basicsj).\r\n\r\n## Benfit For React Code\r\n\r\nImagine this component to show a WordPress post:\r\n\r\n```jsx\r\nconst Post = ({ title, content, author }) => (\r\n\t<div>\r\n\t\t<PostTitle title={title} />\r\n\t\t<PostContent content={content} />\r\n\t\t<PostAuthor author={author} />\r\n\t</div>\r\n);\r\n```\r\n\r\nThis component **assumess** that its props match the expected props of the child components. We can test that's the case with tests that have the correct props:\r\n\r\n```jsx\r\ndescribe(\"Post\", () => {\r\n\tit(\"Puts the title in the right place\", () => {\r\n        //Shallow is enzyme's shallow renderer\r\n        const post = {\r\n            title : {\r\n                rendered: 'Hello Saturn'\r\n            };\r\n            //...\r\n        };\r\n        //render with sample data\r\n\t\tconst wrapper = shallow(\r\n\t\t\t<Post {...post} />\r\n\t\t);\r\n        //Make sure prop is passed correctly\r\n\t\texpect(wrapper.find(PostTitle).prop(\"title\")).toBe(post.title.rendered);\r\n\t});\r\n});\r\n```\r\n\r\nA good thing about this test is that if there are run time erros causesd by running this component, the tests will show you those erorrs. This test is an example of [what I condsider an anti-pattern](https://react-wordpress-testing.joshpress.net/testing-react-apps/3-unit-testing-react) -- testing React's functionality, not the actual code being created.\r\n\r\nThis type of rigid testing makes refactoring safe, and gives us assurances our props are mapped correctly. But, it's also a a lot of boring test code. This kind of test likely will need to get rewritten as the componets are refactored, and that's a bad smell.\r\n\r\nThe problem this kind of testing solves is thatwe could have **run-time** errors if the componets and sub-components being tested are not used according to what we assume there public APIs, errors will happen. We can assume that if we run the components in a production-like environment, and errors happen, that corrisponds to what an end user would describe as \"broken\" in a product environment.\r\n\r\nOK, fine, but two questions:\r\n\r\n1. Why are we assuming the public API of the components?\r\n2. Why do we have to wait until the program is run to see its errors?\r\n\r\nIf we are implimenting the component to show the title of a WordPress post, it might look like this, assuming title is a string, not an object, as its returned from the WordPress REST API:\r\n\r\n```jsx\r\nconst PostTitle = ({ title }) => <h1>{title}</h1>;\r\n```\r\n\r\nJust looking at this code, I can see it has a bug and will generate an error when it runs:\r\n\r\n```jsx\r\nconst post = {\r\n    title : {\r\n        rendered: 'Hello Saturn'\r\n    };\r\n    //...\r\n};\r\nconst PostTitle = ({ title }) => <h1>{title}</h1>;\r\nconst Post = ({post})=> <div><PostTitle title={post.title} /></div>;\r\n```\r\n\r\nI can see this will generate an error, beacuse I can infer how the code is supposed to work by running it. Right now, to get my computer to show that error, I have to run the code, which seems silly, a computer should be able to know how it is supposed to be used.\r\n\r\nThis is why we have static analysis. Before we compile our JSX to JavaScript or compile any JavaScript from the dialect we are writing in to one that runs in the browser, or our server, we can opt into analyzing the code for likely erros caused by passing the wrong types to functions -- for example the props passed to a React component.\r\n\r\n```tsx\r\nconst post = {\r\n    title : {\r\n        rendered: 'Hello Saturn'\r\n    };\r\n    //...\r\n};\r\nconst PostTitle = (props: { title:string }) => <h1>{title}</h1>;\r\nconst Post = (props: {title: {rendered:string}})=> (\r\n    <div>\r\n        <PostTitle title={post.title} />\r\n    </div>\r\n);\r\n```\r\n\r\nNow, this is as obviously wrong to the Typescript compiler as it is to me and requires refactoring to:\r\n\r\n```tsx\r\nconst PostTitle = (props: { title: string }) => <h1>{title}</h1>;\r\nconst Post = (props: { title: { rendered: string } }) => (\r\n\t<div>\r\n\t\t<PostTitle title={post.title.rendered} />\r\n\t</div>\r\n);\r\n```\r\n\r\nNow, that I'm not assuming the public API of my components, the compiler and my IDE can tell me in advance if I am using the components correctly or now.\r\n\r\nOr maybe this component will take the whole post object, not just the string, and handle getting to the right part of the title object:\r\n\r\n```jsx\r\nconst PostTitle = ({ title }) => <h1>{title.rendered}</h1>;\r\n```\r\n\r\nOr maybe we want the whole post, so we can use it's ID and post type in the markup:\r\n\r\n```jsx\r\nconst PostTitle = ({ post }) => (\r\n\t<h1 className={post.type} id={post.id}>\r\n\t\t{post.title.rendered}\r\n\t</h1>\r\n);\r\n```\r\n\r\nMost likely I'm going to go through several implimentations before I find something that works. For each change, I need to know that my props are mapped correctly. Instead of rewriting my tests, or writing tests outside of my unique business logic, I'm going to assume that if my components are used correctly, that React will run them correctly.\r\n","slug":"typescript-basics","references":[]},"slug":"typescript-basics"},"__N_SSG":true}