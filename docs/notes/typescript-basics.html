<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Code Meadow | Code Meadow</title><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@JoshBotDotJs"/><meta name="twitter:creator" content="@josh412"/><meta property="og:type" content="website"/><meta property="og:title" content="Code Meadow | Code Meadow"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Code Meadow"/><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="--- 
title: Basics of Typesscript
slug: typescript-basics
---

## Introduction

### Why

Typescript makes it harder to write JavaScript incorrectly.

### What

Typescript is a dailect of JavaScript that adds new syntax to defin"/><meta property="og:description" content="Notes about undefined by Josh Pollock"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/cca04fbbb4a438761d0c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cca04fbbb4a438761d0c.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-e4ef205fca5d93de439a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.0aee811b7a2ba0b587bf.js" as="script"/><link rel="preload" href="/_next/static/chunks/eeb0540607e8d823f414da745296801d6a447ba7.858a4b022f4a82e30045.js" as="script"/><link rel="preload" href="/_next/static/chunks/e9acf14add5c4f122717233c5b8bc320320f96b1.9770bfbcaacf48f0cbd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/3a4d373e4f729ad3d1487c5b24727311a83f72b6.1b64e79295a1df5d1055.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-07968f6b930f7e33ee5d.js" as="script"/><link rel="preload" href="/_next/static/chunks/cf2f3e6cb2c7250386e9cd655729b7b20c55eb51.d50059c19d19ed2ffbbe.js" as="script"/><link rel="preload" href="/_next/static/chunks/65446de8fdf4c7aed854cb7642630d677689ed10.8064b77b3f659fccd883.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/notes/%5Bslug%5D-33ce1adf9c0915fcb744.js" as="script"/></head><body><div id="__next"><div class="layout"><header id="header" role="banner"><a aria-current="page" class="" href="/"><span>Code Meadow</span></a><div class="controls"><button title="Show Graph visualisation" aria-label="Show Graph visualisation" class="graph-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" class="graph-closed"><g fill="none" stroke-width="2"><circle cx="11.733" cy="3.181" r="1.902"></circle><circle cx="16.864" cy="10.861" r="1.902"></circle><circle cx="7.47" cy="16.822" r="1.902"></circle><circle cx="3.046" cy="6.275" r="1.902"></circle><circle cx="9.372" cy="10.861" r="1.902"></circle><line x1="11.635" x2="14.655" y1="10.861" y2="10.861"></line><line x1="10" x2="10.895" y1="8.959" y2="5.573"></line><line x1="7.47" x2="4.5" y1="9.68" y2="7.5"></line><line x1="8.25" x2="8.809" y1="14.92" y2="13.088"></line></g></svg></button><label class="dark-mode-toggle" aria-label="Activate dark mode" title="Activate dark mode"><input type="checkbox" checked=""/><div></div></label></div></header><main><div class="note-columns-scrolling-container"><div class="note-columns-container"><div class="note-container note-open note-focus animate-pulse opacity-40"><div class="note-buttons"></div><div id="" class="note-content"><h1 class="animate-pulse"></h1><div class="prose note-markdown"><hr/>
<h2 class="mb-4"> <!-- -->title: Basics of Typesscript
slug: typescript-basics</h2>
<h2 class="mb-4"> <!-- -->Introduction</h2>
<h3 class="mb-4"> <!-- -->Why</h3>
<p class="mb-4"> <!-- -->Typescript makes it harder to write JavaScript incorrectly.</p>
<h3 class="mb-4"> <!-- -->What</h3>
<p class="mb-4"> <!-- -->Typescript is a dailect of JavaScript that adds new syntax to define types and interfaces for variables, function arguments, function return types and objects. The typescript compiler to</p>
<h3 class="mb-4"> <!-- -->Quick Start</h3>
<p class="mb-4"> <!-- -->To get started with Typescript without worrying about setup, you can create a new project using <a href="https://github.com/jaredpalmer/tsdx">tsdx</a>:</p>
<pre><code>npx tsdx create learn-typescript
</code></pre>
<p class="mb-4"> <!-- -->Also, <a href="https://create-react-app.dev/docs/adding-typescript/">adding typescript to create-react-app</a> is documented and straight-forward.</p>
<p class="mb-4"> <!-- -->I wrote <a href="https://pantheon.io/blog/typescript-wordpress-basicsj">a longer introduction for Pantheon</a>.</p>
<h2 class="mb-4"> <!-- -->Benfit For React Code</h2>
<p class="mb-4"> <!-- -->Imagine this component to show a WordPress post:</p>
<pre><code>const Post = ({ title, content, author }) =&gt; (
	&lt;div&gt;
		&lt;PostTitle title={title} /&gt;
		&lt;PostContent content={content} /&gt;
		&lt;PostAuthor author={author} /&gt;
	&lt;/div&gt;
);
</code></pre>
<p class="mb-4"> <!-- -->This component <strong>assumess</strong> that its props match the expected props of the child components. We can test that&#x27;s the case with tests that have the correct props:</p>
<pre><code>describe(&quot;Post&quot;, () =&gt; {
	it(&quot;Puts the title in the right place&quot;, () =&gt; {
        //Shallow is enzyme&#x27;s shallow renderer
        const post = {
            title : {
                rendered: &#x27;Hello Saturn&#x27;
            };
            //...
        };
        //render with sample data
		const wrapper = shallow(
			&lt;Post {...post} /&gt;
		);
        //Make sure prop is passed correctly
		expect(wrapper.find(PostTitle).prop(&quot;title&quot;)).toBe(post.title.rendered);
	});
});
</code></pre>
<p class="mb-4"> <!-- -->A good thing about this test is that if there are run time erros causesd by running this component, the tests will show you those erorrs. This test is an example of <a href="https://react-wordpress-testing.joshpress.net/testing-react-apps/3-unit-testing-react">what I condsider an anti-pattern</a> -- testing React&#x27;s functionality, not the actual code being created.</p>
<p class="mb-4"> <!-- -->This type of rigid testing makes refactoring safe, and gives us assurances our props are mapped correctly. But, it&#x27;s also a a lot of boring test code. This kind of test likely will need to get rewritten as the componets are refactored, and that&#x27;s a bad smell.</p>
<p class="mb-4"> <!-- -->The problem this kind of testing solves is thatwe could have <strong>run-time</strong> errors if the componets and sub-components being tested are not used according to what we assume there public APIs, errors will happen. We can assume that if we run the components in a production-like environment, and errors happen, that corrisponds to what an end user would describe as &quot;broken&quot; in a product environment.</p>
<p class="mb-4"> <!-- -->OK, fine, but two questions:</p>
<ol>
<li>Why are we assuming the public API of the components?</li>
<li>Why do we have to wait until the program is run to see its errors?</li>
</ol>
<p class="mb-4"> <!-- -->If we are implimenting the component to show the title of a WordPress post, it might look like this, assuming title is a string, not an object, as its returned from the WordPress REST API:</p>
<pre><code>const PostTitle = ({ title }) =&gt; &lt;h1&gt;{title}&lt;/h1&gt;;
</code></pre>
<p class="mb-4"> <!-- -->Just looking at this code, I can see it has a bug and will generate an error when it runs:</p>
<pre><code>const post = {
    title : {
        rendered: &#x27;Hello Saturn&#x27;
    };
    //...
};
const PostTitle = ({ title }) =&gt; &lt;h1&gt;{title}&lt;/h1&gt;;
const Post = ({post})=&gt; &lt;div&gt;&lt;PostTitle title={post.title} /&gt;&lt;/div&gt;;
</code></pre>
<p class="mb-4"> <!-- -->I can see this will generate an error, beacuse I can infer how the code is supposed to work by running it. Right now, to get my computer to show that error, I have to run the code, which seems silly, a computer should be able to know how it is supposed to be used.</p>
<p class="mb-4"> <!-- -->This is why we have static analysis. Before we compile our JSX to JavaScript or compile any JavaScript from the dialect we are writing in to one that runs in the browser, or our server, we can opt into analyzing the code for likely erros caused by passing the wrong types to functions -- for example the props passed to a React component.</p>
<pre><code>const post = {
    title : {
        rendered: &#x27;Hello Saturn&#x27;
    };
    //...
};
const PostTitle = (props: { title:string }) =&gt; &lt;h1&gt;{title}&lt;/h1&gt;;
const Post = (props: {title: {rendered:string}})=&gt; (
    &lt;div&gt;
        &lt;PostTitle title={post.title} /&gt;
    &lt;/div&gt;
);
</code></pre>
<p class="mb-4"> <!-- -->Now, this is as obviously wrong to the Typescript compiler as it is to me and requires refactoring to:</p>
<pre><code>const PostTitle = (props: { title: string }) =&gt; &lt;h1&gt;{title}&lt;/h1&gt;;
const Post = (props: { title: { rendered: string } }) =&gt; (
	&lt;div&gt;
		&lt;PostTitle title={post.title.rendered} /&gt;
	&lt;/div&gt;
);
</code></pre>
<p class="mb-4"> <!-- -->Now, that I&#x27;m not assuming the public API of my components, the compiler and my IDE can tell me in advance if I am using the components correctly or now.</p>
<p class="mb-4"> <!-- -->Or maybe this component will take the whole post object, not just the string, and handle getting to the right part of the title object:</p>
<pre><code>const PostTitle = ({ title }) =&gt; &lt;h1&gt;{title.rendered}&lt;/h1&gt;;
</code></pre>
<p class="mb-4"> <!-- -->Or maybe we want the whole post, so we can use it&#x27;s ID and post type in the markup:</p>
<pre><code>const PostTitle = ({ post }) =&gt; (
	&lt;h1 className={post.type} id={post.id}&gt;
		{post.title.rendered}
	&lt;/h1&gt;
);
</code></pre>
<p class="mb-4"> <!-- -->Most likely I&#x27;m going to go through several implimentations before I find something that works. For each change, I need to know that my props are mapped correctly. Instead of rewriting my tests, or writing tests outside of my unique business logic, I&#x27;m going to assume that if my components are used correctly, that React will run them correctly.</p></div></div></div><div id="" class="note-content"></div><div id="" class="note-content"></div></div></div></main><footer class="bg-white dark:bg-gray-300 border-t border-gray-500 shadow"><div class="container mx-auto flex py-8"><div class="w-full mx-auto flex flex-wrap"><div class="flex w-full lg:w-1/2 "><div class="px-8"><h3 class="font-bold text-gray-900"><a href="/about">About</a></h3><p class="py-4 text-gray-600 text-sm">By <!-- -->Josh Pollock<!-- -->. Built with <a href="https://digitalgardenbuilder.app/" target="_blank" rel="noopener noreferrer">Digital Garden Builder</a></p></div></div><div class="flex w-full lg:w-1/2 lg:justify-end lg:text-right"><div class="px-8"><h3 class="font-bold text-gray-900">Social</h3><ul class="list-reset items-center text-sm pt-3"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-900 hover:underline py-1" href="https://twitter.com/@josh412">Twitter</a></li></ul></div></div><div class="flex w-full lg:justify-end lg:text-right"></div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"content":"--- \r\ntitle: Basics of Typesscript\r\nslug: typescript-basics\r\n---\r\n\r\n## Introduction\r\n\r\n### Why\r\n\r\nTypescript makes it harder to write JavaScript incorrectly.\r\n\r\n### What\r\n\r\nTypescript is a dailect of JavaScript that adds new syntax to define types and interfaces for variables, function arguments, function return types and objects. The typescript compiler to\r\n\r\n### Quick Start\r\n\r\nTo get started with Typescript without worrying about setup, you can create a new project using [tsdx](https://github.com/jaredpalmer/tsdx):\r\n\r\n```bash\r\nnpx tsdx create learn-typescript\r\n```\r\n\r\nAlso, [adding typescript to create-react-app](https://create-react-app.dev/docs/adding-typescript/) is documented and straight-forward.\r\n\r\nI wrote [a longer introduction for Pantheon](https://pantheon.io/blog/typescript-wordpress-basicsj).\r\n\r\n## Benfit For React Code\r\n\r\nImagine this component to show a WordPress post:\r\n\r\n```jsx\r\nconst Post = ({ title, content, author }) =\u003e (\r\n\t\u003cdiv\u003e\r\n\t\t\u003cPostTitle title={title} /\u003e\r\n\t\t\u003cPostContent content={content} /\u003e\r\n\t\t\u003cPostAuthor author={author} /\u003e\r\n\t\u003c/div\u003e\r\n);\r\n```\r\n\r\nThis component **assumess** that its props match the expected props of the child components. We can test that's the case with tests that have the correct props:\r\n\r\n```jsx\r\ndescribe(\"Post\", () =\u003e {\r\n\tit(\"Puts the title in the right place\", () =\u003e {\r\n        //Shallow is enzyme's shallow renderer\r\n        const post = {\r\n            title : {\r\n                rendered: 'Hello Saturn'\r\n            };\r\n            //...\r\n        };\r\n        //render with sample data\r\n\t\tconst wrapper = shallow(\r\n\t\t\t\u003cPost {...post} /\u003e\r\n\t\t);\r\n        //Make sure prop is passed correctly\r\n\t\texpect(wrapper.find(PostTitle).prop(\"title\")).toBe(post.title.rendered);\r\n\t});\r\n});\r\n```\r\n\r\nA good thing about this test is that if there are run time erros causesd by running this component, the tests will show you those erorrs. This test is an example of [what I condsider an anti-pattern](https://react-wordpress-testing.joshpress.net/testing-react-apps/3-unit-testing-react) -- testing React's functionality, not the actual code being created.\r\n\r\nThis type of rigid testing makes refactoring safe, and gives us assurances our props are mapped correctly. But, it's also a a lot of boring test code. This kind of test likely will need to get rewritten as the componets are refactored, and that's a bad smell.\r\n\r\nThe problem this kind of testing solves is thatwe could have **run-time** errors if the componets and sub-components being tested are not used according to what we assume there public APIs, errors will happen. We can assume that if we run the components in a production-like environment, and errors happen, that corrisponds to what an end user would describe as \"broken\" in a product environment.\r\n\r\nOK, fine, but two questions:\r\n\r\n1. Why are we assuming the public API of the components?\r\n2. Why do we have to wait until the program is run to see its errors?\r\n\r\nIf we are implimenting the component to show the title of a WordPress post, it might look like this, assuming title is a string, not an object, as its returned from the WordPress REST API:\r\n\r\n```jsx\r\nconst PostTitle = ({ title }) =\u003e \u003ch1\u003e{title}\u003c/h1\u003e;\r\n```\r\n\r\nJust looking at this code, I can see it has a bug and will generate an error when it runs:\r\n\r\n```jsx\r\nconst post = {\r\n    title : {\r\n        rendered: 'Hello Saturn'\r\n    };\r\n    //...\r\n};\r\nconst PostTitle = ({ title }) =\u003e \u003ch1\u003e{title}\u003c/h1\u003e;\r\nconst Post = ({post})=\u003e \u003cdiv\u003e\u003cPostTitle title={post.title} /\u003e\u003c/div\u003e;\r\n```\r\n\r\nI can see this will generate an error, beacuse I can infer how the code is supposed to work by running it. Right now, to get my computer to show that error, I have to run the code, which seems silly, a computer should be able to know how it is supposed to be used.\r\n\r\nThis is why we have static analysis. Before we compile our JSX to JavaScript or compile any JavaScript from the dialect we are writing in to one that runs in the browser, or our server, we can opt into analyzing the code for likely erros caused by passing the wrong types to functions -- for example the props passed to a React component.\r\n\r\n```tsx\r\nconst post = {\r\n    title : {\r\n        rendered: 'Hello Saturn'\r\n    };\r\n    //...\r\n};\r\nconst PostTitle = (props: { title:string }) =\u003e \u003ch1\u003e{title}\u003c/h1\u003e;\r\nconst Post = (props: {title: {rendered:string}})=\u003e (\r\n    \u003cdiv\u003e\r\n        \u003cPostTitle title={post.title} /\u003e\r\n    \u003c/div\u003e\r\n);\r\n```\r\n\r\nNow, this is as obviously wrong to the Typescript compiler as it is to me and requires refactoring to:\r\n\r\n```tsx\r\nconst PostTitle = (props: { title: string }) =\u003e \u003ch1\u003e{title}\u003c/h1\u003e;\r\nconst Post = (props: { title: { rendered: string } }) =\u003e (\r\n\t\u003cdiv\u003e\r\n\t\t\u003cPostTitle title={post.title.rendered} /\u003e\r\n\t\u003c/div\u003e\r\n);\r\n```\r\n\r\nNow, that I'm not assuming the public API of my components, the compiler and my IDE can tell me in advance if I am using the components correctly or now.\r\n\r\nOr maybe this component will take the whole post object, not just the string, and handle getting to the right part of the title object:\r\n\r\n```jsx\r\nconst PostTitle = ({ title }) =\u003e \u003ch1\u003e{title.rendered}\u003c/h1\u003e;\r\n```\r\n\r\nOr maybe we want the whole post, so we can use it's ID and post type in the markup:\r\n\r\n```jsx\r\nconst PostTitle = ({ post }) =\u003e (\r\n\t\u003ch1 className={post.type} id={post.id}\u003e\r\n\t\t{post.title.rendered}\r\n\t\u003c/h1\u003e\r\n);\r\n```\r\n\r\nMost likely I'm going to go through several implimentations before I find something that works. For each change, I need to know that my props are mapped correctly. Instead of rewriting my tests, or writing tests outside of my unique business logic, I'm going to assume that if my components are used correctly, that React will run them correctly.\r\n","slug":"typescript-basics","references":[]},"slug":"typescript-basics"},"__N_SSG":true},"page":"/notes/[slug]","query":{"slug":"typescript-basics"},"buildId":"hXTOQKDDRPRTyuRNP4eS2","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-1031cf0bba78a873b9b2.js"></script><script src="/_next/static/chunks/main-e4ef205fca5d93de439a.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.0aee811b7a2ba0b587bf.js" async=""></script><script src="/_next/static/chunks/eeb0540607e8d823f414da745296801d6a447ba7.858a4b022f4a82e30045.js" async=""></script><script src="/_next/static/chunks/e9acf14add5c4f122717233c5b8bc320320f96b1.9770bfbcaacf48f0cbd9.js" async=""></script><script src="/_next/static/chunks/3a4d373e4f729ad3d1487c5b24727311a83f72b6.1b64e79295a1df5d1055.js" async=""></script><script src="/_next/static/chunks/pages/_app-07968f6b930f7e33ee5d.js" async=""></script><script src="/_next/static/chunks/cf2f3e6cb2c7250386e9cd655729b7b20c55eb51.d50059c19d19ed2ffbbe.js" async=""></script><script src="/_next/static/chunks/65446de8fdf4c7aed854cb7642630d677689ed10.8064b77b3f659fccd883.js" async=""></script><script src="/_next/static/chunks/pages/notes/%5Bslug%5D-33ce1adf9c0915fcb744.js" async=""></script><script src="/_next/static/hXTOQKDDRPRTyuRNP4eS2/_buildManifest.js" async=""></script><script src="/_next/static/hXTOQKDDRPRTyuRNP4eS2/_ssgManifest.js" async=""></script></body></html>